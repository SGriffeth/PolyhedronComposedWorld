
    public class ChunkGenerator
    {
        public static int ChunkSize = 8;
        public int Width = ChunkSize;
        public int Depth = ChunkSize;
        Vector3[] vertices;
        int[] triangles;
        Mesh currentMesh;

        public Mesh CurrentMesh()
        {
            return currentMesh;
        }
        
        public GameObject TriangleChunk(float x, float y, float z, float noiseX, float noiseZ)
        {
            vertices = new Vector3[(Width + 1) * (Depth + 1)];
            int i = 0;
            for (float z1 = 0; z1 <= Depth; z1++)
            {
                for (float x1 = 0; x1 <= Width; x1++)
                {
                    float y1 = Mathf.PerlinNoise(noiseX * .3f, noiseZ * .3f) * 3f;
                    vertices[i] = new Vector3(x1, y1, z1);
                    i++;
                    noiseX++;
                }
                noiseZ++;
            }

            triangles = new int[Width * Depth * 6];
            int triIndex = 0;
            for (int vertex = 0; vertex <= vertices.Length && triIndex < triangles.Length; vertex++)
            {
                if (vertices[vertex].x >= Width/* + x*/ || vertices[vertex].z >= Depth/* + z*/)
                {
                    continue;
                }
                triangles[triIndex + 0] = vertex;
                triangles[triIndex + 1] = vertex + Width + 1;
                triangles[triIndex + 2] = vertex + 1;

                triangles[triIndex + 3] = vertex + 1;
                triangles[triIndex + 4] = vertex + Width + 1;
                triangles[triIndex + 5] = vertex + Width + 2;

                triIndex += 6;
            }
            GameObject chunk = new GameObject("TriangleChunk", typeof(MeshFilter), typeof(MeshRenderer), typeof(MeshCollider));
            chunk.transform.position = new Vector3(x, y, z);
            Mesh mesh = new Mesh();
            mesh.vertices = vertices;
            mesh.triangles = triangles;
            chunk.GetComponent<MeshFilter>().mesh = mesh;
            chunk.GetComponent<MeshCollider>().sharedMesh = mesh;
            mesh.RecalculateNormals();
            return chunk;
        }

        public GameObject CubicalChunk(float x, float y, float z, Vector3[] vertices)
        {

            GameObject cubes = new GameObject("CubeChunk");
            cubes.transform.position = new Vector3(x, y, z);
            cubes.layer = 3;

            for (int vert = 0; vert < vertices.Length; vert++)
            {
                if (vertices[vert].x >= Width || vertices[vert].z >= Depth)
                {
                    Debug.Log("continue because " + vertices[vert].x + ", " + vertices[vert].z);
                    continue;
                }
                float x1 = vertices[vert].x;
                float z1 = vertices[vert].z;

                GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube);
                cube.layer = 3;
                cube.transform.parent = cubes.transform;
                Vector3 scale = cube.transform.localScale;

                float average = (vertices[vert].y + vertices[vert + 1].y + vertices[vert + Width + 1].y + vertices[vert + Width + 2].y) / 4f;
                cube.transform.localPosition = new Vector3(x1 + (scale.x / 2f), average, z1 + (scale.z / 2f));
            }
            return cubes;
        }

    }